server {
    listen 80;
    server_name _;

    # Large file support
    client_max_body_size 20G;
    chunked_transfer_encoding on;
    client_body_buffer_size 10M;
    client_body_temp_path /tmp/nginx/client_temp 1 2;

    # Timeouts
    client_body_timeout 300s;
    client_header_timeout 300s;
    keepalive_timeout 300s;
    proxy_connect_timeout 60s;
    proxy_send_timeout 300s;
    proxy_read_timeout 300s;

    # ==========================================================================
    # DNS RESOLVER CONFIGURATION - READ THIS BEFORE MODIFYING
    # ==========================================================================
    #
    # This resolver is used by:
    # 1. Lua HTTP client (resolver.lua) to query mesh-router-backend
    # 2. proxy_pass when $backend contains a hostname (usually it's an IP)
    #
    # IMPORTANT: Do NOT add public DNS servers (8.8.8.8, 1.1.1.1) here!
    #
    # Why? The BACKEND_URL env var uses Docker hostnames (e.g., mesh-router-backend-inojob).
    # If you add public DNS, nginx may query them in parallel with Docker DNS.
    # Public DNS returns NXDOMAIN for Docker hostnames, causing intermittent 502 errors
    # when the public DNS response arrives before Docker DNS.
    #
    # For Docker deployments: Use 127.0.0.11 (Docker's embedded DNS)
    # For non-Docker deployments: Change to your system DNS and use IP/hostname in BACKEND_URL
    #
    # ==========================================================================
    resolver 127.0.0.11 valid=30s ipv6=off;
    resolver_timeout 5s;

    # Variables set by Lua resolver
    set $backend "";
    set $proxy_host "";
    set $proxy_ssl_name "";

    # Health check endpoint
    location = /_health {
        default_type application/json;
        return 200 '{"status":"ok"}';
    }

    # Main routing
    location / {
        # Resolve domain to backend IP:port
        access_by_lua_file /etc/nginx/lua/resolver.lua;

        # Log final status after request completes
        log_by_lua_block {
            local req_id = ngx.req.get_headers()["X-Request-ID"] or "unknown"
            local status = ngx.status
            local upstream_status = ngx.var.upstream_status or "nil"
            local upstream_addr = ngx.var.upstream_addr or "nil"
            local request_time = ngx.var.request_time or "nil"

            if status >= 500 then
                ngx.log(ngx.ERR, "[", req_id, "] request_error status=", status, " upstream_status=", upstream_status, " upstream=", upstream_addr, " time=", request_time, "s")
            else
                ngx.log(ngx.INFO, "[", req_id, "] request_done status=", status, " upstream_status=", upstream_status, " upstream=", upstream_addr, " time=", request_time, "s")
            end
        }

        # Proxy to resolved backend
        proxy_pass $backend;
        proxy_http_version 1.1;

        # SSL settings for HTTPS backends (PCS instances)
        # $proxy_ssl_name is set by Lua resolver to original hostname for SNI
        # This enables TLS cert matching on PCS Caddy when connecting to raw IP
        proxy_ssl_server_name on;
        proxy_ssl_name $proxy_ssl_name;
        proxy_ssl_verify on;
        proxy_ssl_trusted_certificate /etc/ssl/certs/ca-certificates.crt;

        # WebSocket support
        set $connection_upgrade '';
        if ($http_upgrade ~* ^(websocket|mqtt|wss)$) {
            set $connection_upgrade 'Upgrade';
        }

        # Proxy headers
        # $proxy_host is set by Lua resolver (uses X-Forwarded-Host if present)
        proxy_set_header Host $proxy_host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Host $host;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $connection_upgrade;

        # Add request ID to response for debugging
        add_header X-Request-ID $http_x_request_id always;

        # Buffering settings for large responses
        proxy_buffering on;
        proxy_buffer_size 128k;
        proxy_buffers 4 256k;
        proxy_busy_buffers_size 256k;

        # Error handling
        proxy_intercept_errors on;
        error_page 502 = @backend_down;
        error_page 504 = @backend_timeout;
    }

    # Error: backend unreachable
    location @backend_down {
        default_type application/json;
        return 502 '{"error":"Backend server is unreachable","code":"BACKEND_DOWN"}';
    }

    # Error: backend timeout
    location @backend_timeout {
        default_type application/json;
        return 504 '{"error":"Backend server timed out","code":"BACKEND_TIMEOUT"}';
    }
}
