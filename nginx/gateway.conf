server {
    listen 80;
    server_name _;

    # Large file support
    client_max_body_size 20G;
    chunked_transfer_encoding on;
    client_body_buffer_size 10M;
    client_body_temp_path /tmp/nginx/client_temp 1 2;

    # Timeouts
    client_body_timeout 300s;
    client_header_timeout 300s;
    keepalive_timeout 300s;
    proxy_connect_timeout 60s;
    proxy_send_timeout 300s;
    proxy_read_timeout 300s;

    # ==========================================================================
    # DNS RESOLVER CONFIGURATION - READ THIS BEFORE MODIFYING
    # ==========================================================================
    #
    # This resolver is used by:
    # 1. Lua HTTP client (resolver.lua) to query mesh-router-backend
    # 2. proxy_pass when $backend contains a hostname (usually it's an IP)
    #
    # IMPORTANT: Do NOT add public DNS servers (8.8.8.8, 1.1.1.1) here!
    #
    # Why? The BACKEND_URL env var uses Docker hostnames (e.g., mesh-router-backend-inojob).
    # If you add public DNS, nginx may query them in parallel with Docker DNS.
    # Public DNS returns NXDOMAIN for Docker hostnames, causing intermittent 502 errors
    # when the public DNS response arrives before Docker DNS.
    #
    # For Docker deployments: Use 127.0.0.11 (Docker's embedded DNS)
    # For non-Docker deployments: Change to your system DNS and use IP/hostname in BACKEND_URL
    #
    # ==========================================================================
    resolver 127.0.0.11 valid=30s ipv6=off;
    resolver_timeout 5s;

    # Variables set by Lua resolver
    set $backend "";
    set $proxy_host "";
    set $proxy_ssl_name "";
    set $mesh_route "";

    # Health check endpoint
    location = /_health {
        default_type application/json;
        return 200 '{"status":"ok"}';
    }

    # Main routing with failover support
    # Flow: resolver.lua (access) -> content_handler.lua (content) -> proxy.lua (failover)
    location / {
        # Resolve domain to routes (stores in ngx.ctx)
        access_by_lua_file /etc/nginx/lua/resolver.lua;

        # Handle request with Lua-based proxy and automatic failover
        # This replaces proxy_pass to enable failover between routes
        content_by_lua_file /etc/nginx/lua/content_handler.lua;

        # Log final status after request completes
        log_by_lua_block {
            local req_id = ngx.ctx.req_id or ngx.req.get_headers()["X-Request-ID"] or "unknown"
            local status = ngx.status
            local request_time = ngx.var.request_time or "nil"

            if status >= 500 then
                ngx.log(ngx.ERR, "[", req_id, "] request_error status=", status, " time=", request_time, "s")
            else
                ngx.log(ngx.INFO, "[", req_id, "] request_done status=", status, " time=", request_time, "s")
            end
        }
    }

    # WebSocket routing (no failover - uses proxy_pass for protocol upgrade)
    # WebSocket connections are long-lived, so failover doesn't make sense
    # The Lua resolver sets $backend to best route for initial connection
    location @websocket {
        internal;

        proxy_pass $backend;
        proxy_http_version 1.1;

        # SSL settings for HTTPS backends
        proxy_ssl_server_name on;
        proxy_ssl_name $proxy_ssl_name;
        proxy_ssl_verify on;
        proxy_ssl_trusted_certificate /etc/ssl/certs/ca-certificates.crt;

        # WebSocket upgrade headers
        proxy_set_header Host $proxy_host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Host $host;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "Upgrade";

        # Longer timeouts for WebSocket connections
        proxy_connect_timeout 60s;
        proxy_send_timeout 3600s;
        proxy_read_timeout 3600s;

        # Add request ID for debugging
        add_header X-Request-ID $http_x_request_id always;
        add_header X-Mesh-Route $mesh_route always;
    }
}
